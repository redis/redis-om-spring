= Quick Start Example
:page-toclevels: 3
:page-pagination:
:source-highlighter: highlight.js

This quick start guide will walk you through building a Spring Boot application that uses Redis OM Spring. We'll build a basic document repository application step-by-step, closely following the roms-documents demo included in the Redis OM Spring repository.

== Prerequisites

Before you begin, make sure you have:

* Java 17 or higher (Spring Boot 3.x requirement)
* Maven 3.6+ or Gradle 7.5+
* Docker (for running Redis)
* Spring Boot 3.3.x or higher (see <<version-requirements>> below)

== Setting Up Redis

Start by running Redis 8, which includes the Query Engine and JSON capabilities:

[source,bash]
----
docker run -p 6379:6379 redis:8.0.0
----

This launches Redis with:

* Redis Query Engine
* JSON capabilities

=== Installing RedisInsight (Optional)

For a graphical interface to manage and visualize your Redis data, we recommend installing the RedisInsight desktop application. It's a standalone GUI tool that can connect to any Redis instance, including Redis 8.

Download RedisInsight desktop from the https://redis.io/docs/latest/operate/redisinsight/install/[Redis website].

Alternatively, you can run RedisInsight as a Docker container:

[source,bash]
----
docker run -d --name redisinsight -p 8001:8001 redislabs/redisinsight:latest
----

Then access RedisInsight at http://localhost:8001

== Step 1: Create a Spring Boot Project

First, let's create a new Maven project with the necessary dependencies:

[source,xml]
----
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    
    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>3.4.5</version>
        <relativePath/>
    </parent>
    
    <groupId>com.example</groupId>
    <artifactId>redis-om-quickstart</artifactId>
    <version>0.0.1-SNAPSHOT</version>
    <name>redis-om-quickstart</name>
    <description>Redis OM Spring Quick Start Demo</description>
    
    <properties>
        <java.version>17</java.version>
        <redis-om-spring.version>1.0.0-RC2</redis-om-spring.version>
    </properties>
    
    <dependencies>
        <!-- Spring Boot -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        
        <!-- Redis OM Spring -->
        <dependency>
            <groupId>com.redis.om</groupId>
            <artifactId>redis-om-spring</artifactId>
            <version>${redis-om-spring.version}</version>
        </dependency>
        
        <!-- Lombok to reduce boilerplate -->
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <optional>true</optional>
        </dependency>
    </dependencies>
    
    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
                <configuration>
                    <excludes>
                        <exclude>
                            <groupId>org.projectlombok</groupId>
                            <artifactId>lombok</artifactId>
                        </exclude>
                    </excludes>
                </configuration>
            </plugin>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <configuration>
                    <annotationProcessorPaths>
                        <path>
                            <groupId>org.springframework.boot</groupId>
                            <artifactId>spring-boot-configuration-processor</artifactId>
                            <version>${project.parent.version}</version>
                        </path>
                        <path>
                            <groupId>org.projectlombok</groupId>
                            <artifactId>lombok</artifactId>
                            <version>${lombok.version}</version>
                        </path>
                        <path>
                            <groupId>com.redis.om</groupId>
                            <artifactId>redis-om-spring</artifactId>
                            <version>${redis-om-spring.version}</version>
                        </path>
                    </annotationProcessorPaths>
                </configuration>
            </plugin>
        </plugins>
    </build>
</project>
----

== Step 2: Create a Basic Spring Boot Application

Now, let's create a simple Spring Boot application class with Redis OM Spring document repositories enabled:

[source,java]
----
package com.example.demo;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

import com.redis.om.spring.annotations.EnableRedisDocumentRepositories;

@SpringBootApplication
@EnableRedisDocumentRepositories  // Enable Redis OM Spring document repositories
public class Application {
    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }
}
----

The `@EnableRedisDocumentRepositories` annotation is key - it enables Redis OM Spring's document repository functionality.

== Step 3: Create Your First Domain Model

Let's create a simple `Company` class to represent companies in our application:

[source,java]
----
package com.example.demo.domain;

import java.util.HashSet;
import java.util.Set;

import org.springframework.data.annotation.Id;
import org.springframework.data.geo.Point;

import com.redis.om.spring.annotations.Document;
import com.redis.om.spring.annotations.Indexed;
import com.redis.om.spring.annotations.Searchable;

import lombok.*;

@Data
@NoArgsConstructor
@RequiredArgsConstructor(staticName = "of")
@Document
public class Company {
    @Id
    private String id;

    @NonNull
    @Searchable
    private String name;

    @Indexed
    private Set<String> tags = new HashSet<>();

    @NonNull
    private String url;

    @NonNull
    @Indexed
    private Point location;

    @NonNull
    @Indexed
    private Integer numberOfEmployees;

    @NonNull
    @Indexed
    private Integer yearFounded;

    private boolean publiclyListed;
}
----

Notice the Redis OM Spring annotations:

- `@Document`: Marks this class as a Redis JSON document
- `@Searchable`: Will create a full-text search field in the schema for the `name` field
- `@Indexed`: Creates an appropriate search field based on the field data type (`NUMERIC` for integer types, `GEO` for Point, `TAG` for the collection types like `Set<String>`)

== Step 4: Create a Repository Interface

Next, let's create a repository interface for the `Company` class. The `RedisDocumentRepository` interface extends `KeyValueRepository` which in turn extends `ListCrudRepository` and `ListPagingAndSortingRepository` providing all the basic methods to interact with your mapped entities:

[source,java]
----
package com.example.demo.repositories;

import java.util.Optional;

import com.example.demo.domain.Company;
import com.redis.om.spring.repository.RedisDocumentRepository;

public interface CompanyRepository extends RedisDocumentRepository<Company, String> {
    // Find one by property
    Optional<Company> findOneByName(String name);
}
----

The repository extends `RedisDocumentRepository` with `Company` as the entity type and `String` as the ID type. We've added a single query method that will find a company by its name. Behind the scenes, ROMS will craft the appropriate Redis Query Engine command to fulfill the request.

== Step 5: Load Sample Data

Now, let's update our application class to load some sample data:

[source,java]
----
package com.example.demo;

import java.util.Set;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.CommandLineRunner;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.context.annotation.Bean;
import org.springframework.data.geo.Point;

import com.example.demo.domain.Company;
import com.example.demo.repositories.CompanyRepository;
import com.redis.om.spring.annotations.EnableRedisDocumentRepositories;

@SpringBootApplication
@EnableRedisDocumentRepositories
public class Application {

    @Autowired
    CompanyRepository companyRepo;

    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }

    @Bean
    CommandLineRunner loadTestData() {
        return args -> {
            // Clear existing data
            companyRepo.deleteAll();
            
            // Create and save companies
            Company redis = Company.of("Redis", "https://redis.com", 
                new Point(-122.066540, 37.377690), 526, 2011);
            redis.setTags(Set.of("fast", "scalable", "reliable"));

            Company microsoft = Company.of("Microsoft", "https://microsoft.com", 
                new Point(-122.124500, 47.640160), 182268, 1975);
            microsoft.setTags(Set.of("innovative", "reliable"));

            companyRepo.save(redis);
            companyRepo.save(microsoft);
            
            System.out.println("Sample data loaded successfully!");
        };
    }
}
----

We've added:

1. An autowired `CompanyRepository`
2. A `CommandLineRunner` bean that:

   - Clears existing data
   - Creates two company entities
   - Sets tags fields on each company
   - Saves the companies to Redis using the repository `save` method (you can also save entities in bulk using the `saveAll` method)

== Step 6: Create a REST Controller

Let's create a REST controller to expose the repository operations:

[source,java]
----
package com.example.demo.controllers;

import java.util.Optional;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;

import com.example.demo.domain.Company;
import com.example.demo.repositories.CompanyRepository;

@RestController
@RequestMapping("/api/companies")
public class CompanyController {
    @Autowired
    CompanyRepository repository;

    @GetMapping
    public Iterable<Company> getAllCompanies() {
        return repository.findAll();
    }

    @GetMapping("{id}")
    public Optional<Company> byId(@PathVariable("id") String id) {
        return repository.findById(id);
    }
    
    @GetMapping("name/{name}")
    public Optional<Company> byName(@PathVariable("name") String name) {
        return repository.findOneByName(name);
    }
}
----

This controller provides endpoints to:

1. Get all companies
2. Find a company by ID
3. Find a company by name

Note that for more complex business logic we would likely use a service class to encapsulate both the data access and business logic. Since we are simply passing thru to exercise the data access, this is acceptable.

== Step 7: Run the Application

Now you can run the application:

[source,bash]
----
./mvnw spring-boot:run
----

Using the browser, of curl we can test it by hitting the following endpoints:

[source,bash]
----
curl http://localhost:8080/api/companies
curl http://localhost:8080/api/companies/name/Redis
----

== Step 8: Add More Query Methods

Now let's enhance our repository with more query capabilities, that will showcase the flexibility of ROMS when creating more complex declarative repository queries:

[source,java]
----
package com.example.demo.repositories;

import java.util.Optional;
import java.util.Set;

import org.springframework.data.geo.Distance;
import org.springframework.data.geo.Point;
import org.springframework.data.repository.query.Param;

import com.example.demo.domain.Company;
import com.redis.om.spring.annotations.Query;
import com.redis.om.spring.repository.RedisDocumentRepository;

public interface CompanyRepository extends RedisDocumentRepository<Company, String> {
    // Find one by property
    Optional<Company> findOneByName(String name);
    
    // Geospatial query
    Iterable<Company> findByLocationNear(Point point, Distance distance);
    
    // Find by tag field using a custom query
    @Query("@tags:{$tags}")
    Iterable<Company> findByTags(@Param("tags") Set<String> tags);
    
    // Find by numeric property
    Iterable<Company> findByNumberOfEmployees(int noe);
    
    // Find by numeric property range
    Iterable<Company> findByNumberOfEmployeesBetween(int noeGT, int noeLT);
    
    // Starting with/ending with
    Iterable<Company> findByNameStartingWith(String prefix);
}
----

We've added:
1. Geospatial queries using `findByLocationNear`
2. Tag-based search using a custom `@Query`
3. Numeric equality and range queries
4. Prefix search with `findByNameStartingWith`

The `@Query` annotation is a low-level way to control the exact content of the generated `FT.SEARCH` command being set to Redis.

== Step 9: Update the Controller

Let's update our controller to expose the new query methods:

[source,java]
----
package com.example.demo.controllers;

import java.util.Optional;
import java.util.Set;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.geo.Distance;
import org.springframework.data.geo.Metrics;
import org.springframework.data.geo.Point;
import org.springframework.web.bind.annotation.*;

import com.example.demo.domain.Company;
import com.example.demo.repositories.CompanyRepository;

@RestController
@RequestMapping("/api/companies")
public class CompanyController {
    @Autowired
    CompanyRepository repository;

    @GetMapping
    public Iterable<Company> getAllCompanies() {
        return repository.findAll();
    }

    @GetMapping("{id}")
    public Optional<Company> byId(@PathVariable("id") String id) {
        return repository.findById(id);
    }
    
    @GetMapping("name/{name}")
    public Optional<Company> byName(@PathVariable("name") String name) {
        return repository.findOneByName(name);
    }
    
    @GetMapping("employees/count/{count}")
    public Iterable<Company> byNumberOfEmployees(@PathVariable("count") int count) {
        return repository.findByNumberOfEmployees(count);
    }
    
    @GetMapping("employees/range/{low}/{high}")
    public Iterable<Company> byNumberOfEmployeesRange(
            @PathVariable("low") int low, 
            @PathVariable("high") int high) {
        return repository.findByNumberOfEmployeesBetween(low, high);
    }
    
    @GetMapping("all")
    public Page<Company> all(Pageable pageable) {
        return repository.findAll(pageable);
    }
    
    @GetMapping("near")
    public Iterable<Company> byLocationNear(
            @RequestParam("lat") double lat,
            @RequestParam("lon") double lon,
            @RequestParam("d") double distance) {
        return repository.findByLocationNear(
            new Point(lon, lat), 
            new Distance(distance, Metrics.MILES)
        );
    }
    
    @GetMapping("name/starts/{prefix}")
    public Iterable<Company> byNameStartingWith(@PathVariable("prefix") String prefix) {
        return repository.findByNameStartingWith(prefix);
    }
    
    @GetMapping("tags")
    public Iterable<Company> byTags(@RequestParam("tags") Set<String> tags) {
        return repository.findByTags(tags);
    }
}
----

== Step 10: Create the Person Entity

Let's add another entity to our application, the `Person` entity contains some full-text (`TEXT`) search fields for the Person's name and a `TAG` field for the email:

[source,java]
----
package com.example.demo.domain;

import org.springframework.data.annotation.Id;

import com.redis.om.spring.annotations.Document;
import com.redis.om.spring.annotations.Indexed;
import com.redis.om.spring.annotations.Searchable;

import lombok.*;

@Data
@NoArgsConstructor
@RequiredArgsConstructor(staticName = "of")
@Document
public class Person {
    @Id
    private String id;

    @NonNull
    @Searchable
    private String firstName;

    @NonNull
    @Searchable
    private String lastName;

    @NonNull
    @Indexed
    private String email;
}
----

== Step 11: Create the Person Repository

In the `PersonRepository` we, once again, use the `@Query` annotation to control the generated `FT.SEARCH` command, although we could have just remove it and the ROMS declarative repository method handling would have handled it on our behalf. Typically, you only want to use `@Query` for very complex queries which might not be possible to deal with declaratively.

[source,java]
----
package com.example.demo.repositories;

import org.springframework.data.repository.query.Param;

import com.example.demo.domain.Person;
import com.redis.om.spring.annotations.Query;
import com.redis.om.spring.repository.RedisDocumentRepository;

public interface PersonRepository extends RedisDocumentRepository<Person, String> {
    @Query("@firstName:{$firstName} @lastName:{$lastName}")
    Iterable<Person> findByFirstNameAndLastName(
        @Param("firstName") String firstName, 
        @Param("lastName") String lastName
    );
}
----

== Step 12: Update Application to Load Person Data

[source,java]
----
package com.example.demo;

import java.util.Set;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.CommandLineRunner;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.context.annotation.Bean;
import org.springframework.data.geo.Point;

import com.example.demo.domain.Company;
import com.example.demo.domain.Person;
import com.example.demo.repositories.CompanyRepository;
import com.example.demo.repositories.PersonRepository;
import com.redis.om.spring.annotations.EnableRedisDocumentRepositories;

@SpringBootApplication
@EnableRedisDocumentRepositories
public class Application {

    @Autowired
    CompanyRepository companyRepo;
    
    @Autowired
    PersonRepository personRepo;

    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }

    @Bean
    CommandLineRunner loadTestData() {
        return args -> {
            // Clear existing company data
            companyRepo.deleteAll();
            
            // Create and save companies
            Company redis = Company.of("Redis", "https://redis.com", 
                new Point(-122.066540, 37.377690), 526, 2011);
            redis.setTags(Set.of("fast", "scalable", "reliable"));

            Company microsoft = Company.of("Microsoft", "https://microsoft.com", 
                new Point(-122.124500, 47.640160), 182268, 1975);
            microsoft.setTags(Set.of("innovative", "reliable"));

            companyRepo.save(redis);
            companyRepo.save(microsoft);
            
            // Clear existing person data
            personRepo.deleteAll();
            
            // Create and save people
            personRepo.save(Person.of("John", "Doe", "john.doe@example.com"));
            personRepo.save(Person.of("Jane", "Smith", "jane.smith@example.com"));
            
            System.out.println("Sample data loaded successfully!");
        };
    }
}
----

== Step 13: Create a Person Controller

The `PersonController` wires in the `PersonController` and uses the built-in repository methods `findAll` and `findById`
, as well as the custom `findByFirstNameAndLastName`:

[source,java]
----
package com.example.demo.controllers;

import java.util.Collections;
import java.util.Optional;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;

import com.example.demo.domain.Person;
import com.example.demo.repositories.PersonRepository;

@RestController
@RequestMapping("/api/people")
public class PersonController {
    @Autowired
    PersonRepository repository;

    @GetMapping
    public Iterable<Person> getAllPeople() {
        return repository.findAll();
    }

    @GetMapping("{id}")
    public Optional<Person> byId(@PathVariable("id") String id) {
        return repository.findById(id);
    }
    
    @GetMapping("search")
    public Iterable<Person> search(
            @RequestParam("firstName") String firstName,
            @RequestParam("lastName") String lastName) {
        Iterable<Person> people = repository.findByFirstNameAndLastName(firstName, lastName);
        if (!people.iterator().hasNext()) {
            return Collections.emptyList();
        } else {
            return people;
        }
    }
}
----

== Step 14: Create the Event Entity for EntityStream API

Now let's create a new entity that we'll use to demonstrate the EntityStream API:

[source,java]
----
package com.example.demo.domain;

import java.time.LocalDateTime;

import org.springframework.data.annotation.Id;

import com.redis.om.spring.annotations.Document;
import com.redis.om.spring.annotations.Indexed;
import com.redis.om.spring.annotations.Searchable;

import lombok.*;

@Data
@NoArgsConstructor
@RequiredArgsConstructor(staticName = "of")
@Document
public class Event {
    @Id
    private String id;

    @NonNull
    @Searchable
    private String name;

    @Indexed
    private LocalDateTime beginDate;

    @Indexed
    private LocalDateTime endDate;
}
----

== Step 15: Create the Event Repository

[source,java]
----
package com.example.demo.repositories;

import com.example.demo.domain.Event;
import com.redis.om.spring.repository.RedisDocumentRepository;

public interface EventRepository extends RedisDocumentRepository<Event, String> {
    // No custom methods needed for now
}
----

== Step 16: Create the Event Service Interface

[source,java]
----
package com.example.demo.service;

import java.time.LocalDateTime;
import java.util.List;

import com.example.demo.domain.Event;

public interface EventService {
    List<Event> searchByBeginDateBetween(LocalDateTime start, LocalDateTime end);
}
----

== Step 17: Implement the Event Service with EntityStream API

[source,java]
----
package com.example.demo.service.impl;

import java.time.LocalDateTime;
import java.util.List;
import java.util.stream.Collectors;

import org.springframework.stereotype.Service;

import com.example.demo.domain.Event;
import com.example.demo.domain.Event$; // Auto-generated metamodel class
import com.example.demo.service.EventService;
import com.redis.om.spring.search.stream.EntityStream;

import lombok.RequiredArgsConstructor;

@Service
@RequiredArgsConstructor
public class EventServiceImpl implements EventService {

    private final EntityStream entityStream;

    @Override
    public List<Event> searchByBeginDateBetween(LocalDateTime start, LocalDateTime end) {
        // Use the metamodel class for type-safe querying
        return entityStream
            .of(Event.class)
            .filter(Event$.BEGIN_DATE.between(start, end))
            .collect(Collectors.toList());
    }
}
----

This shows how to use the Entity Streams API with the auto-generated metamodel class `Event$`. The metamodel provides type-safe access to entity properties
and their operations applicable in the context of searching. For example, the `filter` method uses the metamodel to find `Event`s with `beginDate`s property (`BEGIN_DATE`) `between` two given values.

== Step 18: Update Application to Load Event Data

[source,java]
----
package com.example.demo;

import java.time.LocalDateTime;
import java.util.Set;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.CommandLineRunner;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.context.annotation.Bean;
import org.springframework.data.geo.Point;

import com.example.demo.domain.Company;
import com.example.demo.domain.Event;
import com.example.demo.domain.Person;
import com.example.demo.repositories.CompanyRepository;
import com.example.demo.repositories.EventRepository;
import com.example.demo.repositories.PersonRepository;
import com.redis.om.spring.annotations.EnableRedisDocumentRepositories;

@SpringBootApplication
@EnableRedisDocumentRepositories
public class Application {

    @Autowired
    CompanyRepository companyRepo;
    
    @Autowired
    PersonRepository personRepo;
    
    @Autowired
    EventRepository eventRepo;

    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }

    @Bean
    CommandLineRunner loadTestData() {
        return args -> {
            // Clear existing company data
            companyRepo.deleteAll();
            
            // Create and save companies
            Company redis = Company.of("Redis", "https://redis.com", 
                new Point(-122.066540, 37.377690), 526, 2011);
            redis.setTags(Set.of("fast", "scalable", "reliable"));

            Company microsoft = Company.of("Microsoft", "https://microsoft.com", 
                new Point(-122.124500, 47.640160), 182268, 1975);
            microsoft.setTags(Set.of("innovative", "reliable"));

            companyRepo.save(redis);
            companyRepo.save(microsoft);
            
            // Clear existing person data
            personRepo.deleteAll();
            
            // Create and save people
            personRepo.save(Person.of("John", "Doe", "john.doe@example.com"));
            personRepo.save(Person.of("Jane", "Smith", "jane.smith@example.com"));
            
            // Clear and load Event data
            eventRepo.deleteAll();
            
            Event conference = Event.of("Redis Conference");
            conference.setBeginDate(LocalDateTime.now().plusDays(30));
            conference.setEndDate(LocalDateTime.now().plusDays(32));
            
            Event workshop = Event.of("Spring Workshop");
            workshop.setBeginDate(LocalDateTime.now().plusDays(15));
            workshop.setEndDate(LocalDateTime.now().plusDays(15).plusHours(8));
            
            Event hackathon = Event.of("Hackathon");
            hackathon.setBeginDate(LocalDateTime.now().plusDays(45));
            hackathon.setEndDate(LocalDateTime.now().plusDays(46));
            
            eventRepo.save(conference);
            eventRepo.save(workshop);
            eventRepo.save(hackathon);
            
            System.out.println("Sample data loaded successfully!");
        };
    }
}
----

== Step 19: Create an Event Controller

The controller will simply wrap the two service methods passing values and providing some defaults to the calls:

[source,java]
----
package com.example.demo.controllers;

import java.time.LocalDateTime;
import java.util.List;

import org.springframework.format.annotation.DateTimeFormat;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

import com.example.demo.domain.Event;
import com.example.demo.service.EventService;

import lombok.RequiredArgsConstructor;

@RestController
@RequestMapping("/api/events")
@RequiredArgsConstructor
public class EventController {

    private final EventService eventService;

    @GetMapping
    public Iterable<Event> getAllEvents() {
        return eventService.searchByBeginDateBetween(
            LocalDateTime.now().minusYears(1),
            LocalDateTime.now().plusYears(1)
        );
    }

    @GetMapping("between")
    public List<Event> byDateRange(
            @RequestParam("start") @DateTimeFormat(iso = DateTimeFormat.ISO.DATE_TIME) LocalDateTime start,
            @RequestParam("end") @DateTimeFormat(iso = DateTimeFormat.ISO.DATE_TIME) LocalDateTime end) {
        
        return eventService.searchByBeginDateBetween(start, end);
    }
}
----

== Step 20: Understanding the Entity Streams API

The Entity Streams API is a powerful feature of Redis OM Spring that allows for more complex and type-safe querying. Here's a closer look:

1. **Generated Metamodel**: For each entity class like `Event`, Redis OM Spring generates a metamodel class `Event$` during compilation, which provides type-safe access to entity properties.

2. **Type-Safe Queries**: The metamodel enables type-safe conditions like `Event$.BEGIN_DATE.between(start, end)`.

3. **Fluent API**: Operations can be chained, like filtering, sorting, and pagination.

4. **Complex Conditions**: Supports complex filter conditions, including:
   * Equality: `.eq(value)`
   * Comparison: `.gt(value)`, `.lt(value)`, `.between(min, max)`
   * Text search: `.match(text)`, `.matchPrefix(prefix)`
   * Geospatial: `.near(point, distance)`
   * Boolean operators: `.and()`, `.or()`

Here's an example of a more complex query using the Entity Streams API:

[source,java]
----
List<Company> findLargeCompaniesWithTag(String tag, int minEmployees) {
  return entityStream
      .of(Company.class)
      .filter(
          Company$.TAGS.contains(tag)
          .and(Company$.NUMBER_OF_EMPLOYEES.gt(minEmployees))
      )
      .sorted(Company$.YEAR_FOUNDED.desc())
      .limit(10)
      .collect(Collectors.toList());
}
----

It is important to understand that as opposed to a regular Java stream, most operations assemble a query or an aggregation to
be executed server-side. On the query above the query is executed during and only during the terminal `collect` operation. At that point you
will have a `List<Company>` objects now loaded in memory.

== Step 21: Lexicographic String Comparisons

Redis OM Spring supports lexicographic (alphabetical) string comparisons for range queries on string fields. This is useful for finding entities within ID ranges, SKU comparisons, or alphabetical filtering.

Let's add a Product entity to demonstrate this feature:

[source,java]
----
package com.example.demo.domain;

import org.springframework.data.annotation.Id;

import com.redis.om.spring.annotations.Document;
import com.redis.om.spring.annotations.Indexed;
import com.redis.om.spring.annotations.Searchable;

import lombok.*;

@Data
@NoArgsConstructor
@RequiredArgsConstructor(staticName = "of")
@Document
public class Product {
    @Id
    private String id;

    @NonNull
    @Searchable
    private String name;

    @NonNull
    @Indexed(lexicographic = true)  // Enable lexicographic comparisons
    private String sku;

    @NonNull
    @Indexed
    private Double price;

    @Indexed(lexicographic = true)  // Version strings can be compared
    private String version;
}
----

Notice the `lexicographic = true` parameter on the `@Indexed` annotation. This tells Redis OM Spring to create an additional sorted set index for string range queries.

== Step 22: Create the Product Repository

[source,java]
----
package com.example.demo.repositories;

import java.util.List;

import com.example.demo.domain.Product;
import com.redis.om.spring.repository.RedisDocumentRepository;

public interface ProductRepository extends RedisDocumentRepository<Product, String> {
    // Lexicographic string comparisons
    List<Product> findBySkuGreaterThan(String sku);
    List<Product> findBySkuLessThan(String sku);
    List<Product> findBySkuBetween(String startSku, String endSku);
    
    // Combine with other conditions
    List<Product> findBySkuGreaterThanAndPriceGreaterThan(String sku, Double price);
    
    // Order by lexicographic field
    List<Product> findByNameContainingOrderBySkuAsc(String keyword);
}
----

These repository methods leverage the lexicographic index to perform efficient string range queries.

== Step 23: Product Service with Entity Streams

[source,java]
----
package com.example.demo.service;

import java.util.List;

import com.example.demo.domain.Product;

public interface ProductService {
    List<Product> findProductsInSkuRange(String startSku, String endSku);
    List<Product> findNewerVersions(String version);
}
----

[source,java]
----
package com.example.demo.service.impl;

import java.util.List;
import java.util.stream.Collectors;

import org.springframework.stereotype.Service;

import com.example.demo.domain.Product;
import com.example.demo.domain.Product$;
import com.example.demo.service.ProductService;
import com.redis.om.spring.search.stream.EntityStream;

import lombok.RequiredArgsConstructor;

@Service
@RequiredArgsConstructor
public class ProductServiceImpl implements ProductService {

    private final EntityStream entityStream;

    @Override
    public List<Product> findProductsInSkuRange(String startSku, String endSku) {
        return entityStream
            .of(Product.class)
            .filter(Product$.SKU.between(startSku, endSku))
            .sorted(Product$.SKU)  // Sort by SKU alphabetically
            .collect(Collectors.toList());
    }

    @Override
    public List<Product> findNewerVersions(String version) {
        return entityStream
            .of(Product.class)
            .filter(Product$.VERSION.gt(version))
            .sorted(Product$.VERSION.desc())
            .collect(Collectors.toList());
    }
}
----

The Entity Streams API provides type-safe methods for lexicographic comparisons:
- `.gt(value)` - Greater than
- `.lt(value)` - Less than  
- `.between(start, end)` - Between two values (inclusive)

== Step 24: Update Application to Load Product Data

[source,java]
----
// Add to the Application class imports
import com.example.demo.domain.Product;
import com.example.demo.repositories.ProductRepository;

// Add to the Application class fields
@Autowired
ProductRepository productRepo;

// Add to the loadTestData() method
// Clear and load Product data
productRepo.deleteAll();

// Create products with sequential SKUs
productRepo.save(Product.of("Laptop Pro", "PROD-1001", 1299.99));
productRepo.save(Product.of("Wireless Mouse", "PROD-1002", 29.99));
productRepo.save(Product.of("USB-C Hub", "PROD-1003", 49.99));
productRepo.save(Product.of("Monitor 4K", "PROD-2001", 599.99));
productRepo.save(Product.of("Keyboard Mechanical", "PROD-2002", 149.99));

// Products with versions
Product software1 = Product.of("Analytics Suite", "SOFT-001", 499.99);
software1.setVersion("2.1.0");
productRepo.save(software1);

Product software2 = Product.of("Database Manager", "SOFT-002", 799.99);
software2.setVersion("3.0.1");
productRepo.save(software2);

Product software3 = Product.of("Cloud Platform", "SOFT-003", 999.99);
software3.setVersion("1.9.5");
productRepo.save(software3);
----

== Step 25: Create the Product Controller

[source,java]
----
package com.example.demo.controllers;

import java.util.List;

import org.springframework.web.bind.annotation.*;

import com.example.demo.domain.Product;
import com.example.demo.repositories.ProductRepository;
import com.example.demo.service.ProductService;

import lombok.RequiredArgsConstructor;

@RestController
@RequestMapping("/api/products")
@RequiredArgsConstructor
public class ProductController {

    private final ProductRepository repository;
    private final ProductService productService;

    @GetMapping
    public Iterable<Product> getAllProducts() {
        return repository.findAll();
    }

    @GetMapping("sku/gt/{sku}")
    public List<Product> bySkuGreaterThan(@PathVariable("sku") String sku) {
        return repository.findBySkuGreaterThan(sku);
    }

    @GetMapping("sku/range/{start}/{end}")
    public List<Product> bySkuRange(
            @PathVariable("start") String start,
            @PathVariable("end") String end) {
        return productService.findProductsInSkuRange(start, end);
    }

    @GetMapping("version/newer/{version}")
    public List<Product> newerVersions(@PathVariable("version") String version) {
        return productService.findNewerVersions(version);
    }
}
----

== Testing Lexicographic Queries

After adding the Product functionality, you can test the lexicographic string comparisons:

Find products with SKU greater than a value:
[source,bash]
----
curl http://localhost:8080/api/products/sku/gt/PROD-1002
# Returns products with SKUs: PROD-1003, PROD-2001, PROD-2002, SOFT-001, etc.
----

Find products in a SKU range:
[source,bash]
----
curl http://localhost:8080/api/products/sku/range/PROD-1001/PROD-2000
# Returns products with SKUs between PROD-1001 and PROD-2000
----

Find software with version newer than 2.0.0:
[source,bash]
----
curl http://localhost:8080/api/products/version/newer/2.0.0
# Returns software with versions > 2.0.0 (e.g., 2.1.0, 3.0.1)
----

The lexicographic feature is particularly useful for:
- **Product SKUs**: Finding products in specific code ranges
- **Sequential IDs**: Querying entities with IDs in a certain range  
- **Version strings**: Comparing semantic versions
- **Alphabetical filtering**: Finding names within alphabetical ranges

== Testing the REST API

After starting your application with `./mvnw spring-boot:run`, you can test the various endpoints:

=== Company Endpoints

Retrieve all companies:
[source,bash]
----
curl http://localhost:8080/api/companies
----

Retrieve a company by name:
[source,bash]
----
curl http://localhost:8080/api/companies/name/Redis
----

Find companies by employee count:
[source,bash]
----
curl http://localhost:8080/api/companies/employees/count/526
----

Find companies in an employee range:
[source,bash]
----
curl http://localhost:8080/api/companies/employees/range/500/200000
----

Find companies near a location:
[source,bash]
----
curl "http://localhost:8080/api/companies/near?lat=37.37&lon=-122.06&d=10"
----

Find companies by name prefix:
[source,bash]
----
curl http://localhost:8080/api/companies/name/starts/Red
----

Find companies by tags:
[source,bash]
----
curl "http://localhost:8080/api/companies/tags?tags=reliable"
----

=== Person Endpoints

Get all people:
[source,bash]
----
curl http://localhost:8080/api/people
----

Search people by first and last name:
[source,bash]
----
curl "http://localhost:8080/api/people/search?firstName=John&lastName=Doe"
----

=== Event Endpoints

Get all events:
[source,bash]
----
curl http://localhost:8080/api/events
----

Find events between dates:
[source,bash]
----
curl "http://localhost:8080/api/events/between?start=2023-06-01T00:00:00&end=2023-07-31T23:59:59"
----

== Testing

Here's an example of how you can test your repositories with TestContainers:

[source,java]
----
package com.example.demo.repositories;

import static org.assertj.core.api.Assertions.assertThat;

import java.util.Set;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.data.geo.Distance;
import org.springframework.data.geo.Metrics;
import org.springframework.data.geo.Point;
import org.springframework.test.context.DynamicPropertyRegistry;
import org.springframework.test.context.DynamicPropertySource;
import org.testcontainers.containers.GenericContainer;
import org.testcontainers.junit.jupiter.Container;
import org.testcontainers.junit.jupiter.Testcontainers;

import com.example.demo.domain.Company;

@SpringBootTest
@Testcontainers
class CompanyRepositoryTest {

    @Container
    static GenericContainer<?> redis = new GenericContainer<>("redis:8.0.0")
            .withExposedPorts(6379);

    @DynamicPropertySource
    static void redisProperties(DynamicPropertyRegistry registry) {
        registry.add("spring.data.redis.host", redis::getHost);
        registry.add("spring.data.redis.port", redis::getFirstMappedPort);
    }

    @Autowired
    private CompanyRepository repository;

    @BeforeEach
    void setup() {
        repository.deleteAll();

        Company redis = Company.of("Redis", "https://redis.com", 
            new Point(-122.066540, 37.377690), 526, 2011);
        redis.setTags(Set.of("fast", "scalable", "reliable"));

        Company microsoft = Company.of("Microsoft", "https://microsoft.com", 
            new Point(-122.124500, 47.640160), 182268, 1975);
        microsoft.setTags(Set.of("innovative", "reliable"));

        repository.save(redis);
        repository.save(microsoft);
    }

    @Test
    void testFindOneByName() {
        assertThat(repository.findOneByName("Redis")).isPresent()
            .get().extracting(Company::getName).isEqualTo("Redis");
    }

    @Test
    void testFindByLocationNear() {
        Iterable<Company> companies = repository.findByLocationNear(
            new Point(-122.066540, 37.377690),
            new Distance(10, Metrics.MILES)
        );
        
        assertThat(companies).hasSize(1)
            .extracting(Company::getName)
            .containsExactly("Redis");
    }
}
----

== Next Steps

This quick start guide demonstrated the basics of Redis OM Spring. To learn more, explore:

* xref:json_mappings.adoc[Redis JSON Basics] for more on JSON document mapping
* xref:entity-streams.adoc[Entity Streams] for advanced querying
* xref:index-annotations.adoc[Index Annotations] for more indexing options
* xref:vector-search.adoc[Vector Search] for AI-powered similarity search
* xref:repository-queries.adoc[Repository Query Methods] for more query capabilities
* Check out the full demo applications in the `/demos` directory of the Redis OM Spring repository