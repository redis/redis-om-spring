= Object Mapping
:page-toclevels: 3
:experimental:
:source-highlighter: highlight.js

== Introduction to Object Mapping

Redis OM Spring provides a robust object mapping framework that allows you to seamlessly map Java objects to Redis data structures. This framework builds on Spring Data's infrastructure while adding enhanced capabilities for working with Redis data models.

== Core Object Mapping Concepts

=== Entity Classes

Entity classes are Plain Old Java Objects (POJOs) that are annotated to indicate they should be persisted to Redis. Redis OM Spring supports two primary mapping strategies:

* `@RedisHash` - For mapping to Redis Hashes (compatible with standard Spring Data Redis)
* `@Document` - For mapping to Redis JSON (Redis OM Spring specific)

Both annotations support additional capabilities when used with Redis OM Spring repositories.

=== Entity IDs

Every entity requires a unique identifier (`@Id`), which can be:

* Explicitly assigned by your application
* Automatically generated by Redis OM Spring using the built-in ULID generator (default)
* Customized using your own ID generator

[source,java]
----
@Document
public class Product {
    @Id
    private String id;  // Will be automatically generated if not provided
    
    private String name;
    private BigDecimal price;
    
    // Constructors, getters, and setters
    public Product() {}
    
    public Product(String name, BigDecimal price) {
        this.name = name;
        this.price = price;
        // Note: No need to set ID - it will be generated
    }
    
    // Getters and setters
}
----

[TIP]
====
Redis OM Spring uses ULID (Universally Unique Lexicographically Sortable Identifier) by default for String `@Id` fields. These IDs are:

* Time-ordered (newer entities sort after older ones)
* URL-safe (base32 encoded)  
* Collision-resistant (128-bit entropy)
* Compact (26 characters)

You can also use the `Ulid` type directly for strongly-typed identifiers:

[source,java]
----
@Document
public class DocWithUlidId {
    @Id
    private Ulid id;  // Will be automatically generated
    
    private String name;
}
----
====

=== Type Conversion

Redis OM Spring handles automatic conversion between Java types and Redis storage formats:

[cols="1,1,1"]
|===
|Java Type |Redis Hash Storage |Redis JSON Storage

|Primitive types (int, long, boolean)
|String representation
|Native JSON number/boolean

|Java wrappers (Integer, Long, Boolean)
|String representation
|Native JSON number/boolean

|String
|String
|JSON string

|BigDecimal, BigInteger
|String representation
|JSON number

|Date, LocalDate, LocalDateTime
|ISO-8601 string
|ISO-8601 string

|Enum
|Name as string
|Name as string

|List<T>
|Supported via serialization*
|JSON array

|Set<T>
|Supported via serialization*
|JSON array (order not preserved)

|Map<K,V>
|Supported via serialization*
|JSON object

|Custom objects
|Supported via serialization*
|Nested JSON object

|Ulid
|String representation
|String representation
|===

*Redis Hashes store complex types as serialized values. For searchable fields within collections or objects, use the JSON Document model.

== Field Mapping

=== Basic Field Mapping

By default, all fields of a class are mapped to Redis using their Java property names:

[source,java]
----
@Document
public class Customer {
    @Id
    private String id;
    private String firstName;    // Mapped to "firstName" field
    private String lastName;     // Mapped to "lastName" field
    private Integer age;         // Mapped to "age" field
    private boolean active;      // Mapped to "active" field
    
    // Getters and setters
}
----

=== Customizing Field Names

You can customize how fields are named in Redis using Jackson's `@JsonProperty` annotation:

[source,java]
----
@Document
public class NotNullAnnotated {
    @Id
    @JsonProperty(required = true)
    private String dbId;
    
    @JsonProperty(required = true)
    @Indexed
    private String someOtherString;
    
    // Field names will be "dbId" and "someOtherString" in Redis
}
----

=== Transient Fields

The standard Java `transient` keyword can be used to exclude fields from persistence:

[source,java]
----
@Document
public class Session {
    @Id
    private String id;
    private String userId;
    
    transient private Object localCache;  // Not persisted to Redis
    
    // Getters and setters
}
----

NOTE: While Jackson annotations like `@JsonIgnore` are supported, using the `transient` keyword is the recommended approach for excluding fields in Redis OM Spring.

== Advanced Mapping Features

=== Embedded Objects

Redis OM Spring supports mapping of embedded objects, with different behavior based on the mapping type:

.JSON Documents (using @Document)
[source,java]
----
@Document
public class Order {
    @Id
    private String id;
    private LocalDateTime orderDate;
    
    // Embedded as a nested JSON object
    private Address shippingAddress;
    
    // Embedded as a JSON array of objects
    private List<OrderItem> items;
}

@Data
@RequiredArgsConstructor(staticName = "of")
public class Address {
    @NonNull
    @Indexed
    private String city;
    
    @NonNull
    @Searchable(nostem = true)
    private String street;
}

@Data  
@RequiredArgsConstructor(staticName = "of")
public class OrderItem {
    @NonNull
    @Indexed
    private String skuNo;
    
    @NonNull
    private Double price;
}
----

.Redis Hashes (using @RedisHash)
[source,java]
----
@RedisHash
public class KitchenSink {
    @Id
    private String id;
    
    @Indexed
    private String name;
    
    // Collections are stored as serialized values in Hash model
    private List<String> stringList;
    private Set<String> stringSet;
    
    // For searchable fields within collections, use @Document instead
}
----

=== Inheritance

Redis OM Spring supports entity inheritance. Here's a simple example from the test suite:

[source,java]
----
// Base abstract class
public abstract class AbstractDocument {
    @Id
    private String id;
    
    @Indexed
    private String inherited;
    
    // Constructors, getters, and setters
}

// Concrete implementation
@Document
public class InheritingDocument extends AbstractDocument {
    @Indexed
    private String notInherited;
    
    // Constructors, getters, and setters
}
----

For more complex inheritance hierarchies with type discrimination, you can use Jackson's `@JsonTypeInfo` and `@JsonSubTypes` annotations.

=== Working with Immutable Objects

Redis OM Spring works well with immutable objects. Use Lombok's `@Value` annotation for the simplest approach:

[source,java]
----
@Value
@Document
public class ImmutableProduct {
    @Id
    String id;
    
    @Indexed
    String name;
    
    @Indexed  
    BigDecimal price;
    
    // Lombok generates constructor, getters, equals, hashCode, toString
    // No setters are generated, making this truly immutable
}
----

For custom constructors, you can use Jackson's `@JsonCreator` and `@JsonProperty` annotations as needed.

=== Lombok Integration

Redis OM Spring works well with Lombok to reduce boilerplate code. Here's an example from the test suite:

[source,java]
----
@Data
@RequiredArgsConstructor(staticName = "of")
@NoArgsConstructor(force = true)  
@Document
public class Product {
    @Id
    private String id;
    
    @Indexed
    @NonNull
    private String name;
    
    @Vectorize(destination = "sentenceEmbedding", embeddingType = EmbeddingType.SENTENCE)
    @NonNull
    private String description;
    
    @Indexed(schemaFieldType = SchemaFieldType.VECTOR)
    private float[] sentenceEmbedding;
}
----

== Redis Version Compatibility

* **Redis 8.0+**: Full support for all Redis OM Spring features with built-in Query Engine and JSON modules
* **Redis prior to 8.0**: Requires Redis Stack for JSON document support and full-text search capabilities

== Next Steps

* xref:entity-ids.adoc[Read more about Entity IDs and ULID]
* xref:hash-mappings.adoc[Learn about Redis Hash mappings]
* xref:json_mappings.adoc[Learn about Redis JSON mappings]
* xref:index-annotations.adoc[Explore indexing capabilities]