= Hybrid Search
:page-toclevels: 3
:page-pagination:

Hybrid Search combines full-text search (BM25) with vector similarity search to deliver results that are both keyword-relevant and semantically meaningful. Redis OM Spring provides two hybrid search implementations that are used automatically depending on your Redis version.

== Understanding Hybrid Search

=== What is Hybrid Search?

Hybrid search combines two complementary search approaches:

1. **Full-Text Search (BM25)**: Traditional keyword-based search that matches query terms against document text using statistical relevance scoring
2. **Vector Similarity Search**: Semantic search using embeddings that captures meaning and context beyond exact keyword matches

The two scores are fused into a single ranking using either **Reciprocal Rank Fusion (RRF)** or **LINEAR** weighted combination.

=== Why Use Hybrid Search?

**Text Search Strengths:**

* Exact keyword matching
* Boolean operators (AND, OR, NOT)
* Phrase matching and proximity
* Fast for specific term lookups

**Vector Search Strengths:**

* Semantic understanding ("laptop" matches "computer")
* Cross-language similarity
* Conceptual relationships
* Handles synonyms and variations

**Combined Benefits:**

* Better relevance than either approach alone
* Handles both precise queries and broad conceptual searches
* More robust to query variations
* Improved user experience

== Two Hybrid Search Implementations

Redis OM Spring supports two hybrid search implementations. The best choice depends on your Redis version:

[cols="1,2,2"]
|===
|Feature |HybridQuery |AggregateHybridQuery

|**Redis Command**
|`FT.HYBRID`
|`FT.AGGREGATE`

|**Min Redis Version**
|8.4+
|7.4+

|**Combination Methods**
|RRF (default), LINEAR
|Weighted linear only

|**Alpha Semantics**
|`linearAlpha` = text weight (default 0.3)
|`alpha` = vector weight (default 0.7)

|**Score Aliases**
|Yes (`yieldTextScoreAs`, `yieldVsimScoreAs`, `yieldCombinedScoreAs`)
|No

|**Automatic Fallback**
|Falls back to AggregateHybridQuery on older Redis
|N/A
|===

== Prerequisites

=== Redis Version Requirements

* **Redis 8.4+** — Recommended. Enables native `FT.HYBRID` command with RRF/LINEAR fusion.
* **Redis 7.4+** — Minimum. Uses `FT.AGGREGATE` with manual score combination.

To check your Redis version:

[source,bash]
----
redis-cli INFO server | grep redis_version
----

=== Dependencies

Redis OM Spring integrates with RedisVL (Redis Vector Library) for hybrid search support. This dependency is included automatically in Redis OM Spring 2.x.

== Setting Up Hybrid Search

=== Entity Definition

To enable hybrid search on an entity, you need:

1. A **full-text searchable field** (using `@Searchable`)
2. A **vector field** (using `@Indexed` with `schemaFieldType = VECTOR`)

[source,java]
----
@Data
@RequiredArgsConstructor(staticName = "of")
@NoArgsConstructor
@RedisHash
public class Product {

  @Id
  private String id;

  @Indexed
  @NonNull
  private String category;

  // Full-text searchable description for BM25 scoring
  @Searchable
  @NonNull
  private String description;

  @Indexed
  @NonNull
  private Double price;

  // Vector field for semantic similarity
  @Indexed(
      schemaFieldType = SchemaFieldType.VECTOR,
      algorithm = VectorAlgorithm.FLAT,
      type = VectorType.FLOAT32,
      dimension = 384,  // Common for sentence transformers
      distanceMetric = DistanceMetric.COSINE
  )
  @NonNull
  private byte[] embedding;
}
----

=== Repository

Create a repository extending `RedisEnhancedRepository`:

[source,java]
----
public interface ProductRepository extends RedisEnhancedRepository<Product, String> {
}
----

== Performing Hybrid Searches

=== Using Entity Streams (High-Level API)

The `hybridSearch()` method on `EntityStream` is the simplest way to perform hybrid search. It automatically tries the native `FT.HYBRID` command first (Redis 8.4+), and falls back to `FT.AGGREGATE` transparently on older Redis versions:

[source,java]
----
@Autowired
private EntityStream entityStream;

// Perform hybrid search (defaults to LINEAR combination)
List<Product> results = entityStream.of(Product.class)
    .hybridSearch(
        "wireless headphones",           // Text query
        Product$.DESCRIPTION,             // Text field
        queryEmbedding,                   // Query vector (float[])
        Product$.EMBEDDING,               // Vector field
        0.7f                              // Alpha (0.0-1.0)
    )
    .limit(10)
    .collect(Collectors.toList());
----

==== Choosing a Combination Method

You can explicitly choose between RRF and LINEAR combination methods using the `CombinationMethod` parameter:

[source,java]
----
import com.redis.om.spring.search.stream.CombinationMethod;

// RRF combination (Reciprocal Rank Fusion)
// Best for combining ranked lists without score normalization
List<Product> rrfResults = entityStream.of(Product.class)
    .hybridSearch(
        "wireless headphones",
        Product$.DESCRIPTION,
        queryEmbedding,
        Product$.EMBEDDING,
        CombinationMethod.RRF,           // RRF combination method
        0.7f                              // Alpha (vector weight)
    )
    .limit(10)
    .collect(Collectors.toList());

// LINEAR combination (weighted linear)
// Explicit weighted combination of text and vector scores
List<Product> linearResults = entityStream.of(Product.class)
    .hybridSearch(
        "wireless headphones",
        Product$.DESCRIPTION,
        queryEmbedding,
        Product$.EMBEDDING,
        CombinationMethod.LINEAR,         // LINEAR combination method
        0.7f                              // Alpha (vector weight)
    )
    .limit(10)
    .collect(Collectors.toList());
----

NOTE: When `CombinationMethod.RRF` is requested but the Redis version does not support `FT.HYBRID` (pre-8.4), the query automatically falls back to `FT.AGGREGATE` with LINEAR combination. The fallback is transparent — results are always returned.

==== Hybrid Search with Filters

Combine hybrid search with filters for refined results:

[source,java]
----
List<Product> results = entityStream.of(Product.class)
    .filter(Product$.CATEGORY.eq("Electronics"))
    .filter(Product$.PRICE.between(100.0, 500.0))
    .hybridSearch(
        "noise cancelling headphones",
        Product$.DESCRIPTION,
        queryEmbedding,
        Product$.EMBEDDING,
        0.7f
    )
    .limit(10)
    .collect(Collectors.toList());
----

=== HybridQuery (FT.HYBRID) — Recommended for Redis 8.4+

`HybridQuery` uses the native `FT.HYBRID` command introduced in Redis 8.4. It supports two score fusion strategies (RRF and LINEAR), score aliases, and automatically falls back to `AggregateHybridQuery` on older Redis versions.

==== Basic Example

[source,java]
----
import com.redis.vl.query.HybridQuery;

HybridQuery query = HybridQuery.builder()
    .text("wireless headphones")
    .textFieldName("description")
    .vector(queryEmbedding)
    .vectorFieldName("embedding")
    .numResults(10)
    .returnFields(List.of("description", "category", "price"))
    .build();
----

==== RRF Combination (Default)

Reciprocal Rank Fusion merges ranked lists from text and vector search without requiring score normalization:

[source,java]
----
HybridQuery rrfQuery = HybridQuery.builder()
    .text("noise cancelling headphones")
    .textFieldName("description")
    .vector(queryEmbedding)
    .vectorFieldName("embedding")
    .combinationMethod(HybridQuery.CombinationMethod.RRF)
    .rrfWindow(20)       // Window size for ranking (default: 20)
    .rrfConstant(60)     // RRF constant (default: 60)
    .numResults(10)
    .build();
----

==== LINEAR Combination

Linear combination weights text and vector scores directly:

[source,java]
----
HybridQuery linearQuery = HybridQuery.builder()
    .text("noise cancelling headphones")
    .textFieldName("description")
    .vector(queryEmbedding)
    .vectorFieldName("embedding")
    .combinationMethod(HybridQuery.CombinationMethod.LINEAR)
    .linearAlpha(0.5f)   // Text weight (0.0-1.0, default: 0.3)
    .numResults(10)
    .build();
----

NOTE: In `HybridQuery`, `linearAlpha` is the **text** weight. An alpha of 0.3 means 30% text / 70% vector.

==== Filter Expressions

Filter results using strongly-typed `Filter` objects or raw RediSearch strings:

[source,java]
----
import com.redis.vl.query.Filter;

// Strongly-typed filter
HybridQuery filteredQuery = HybridQuery.builder()
    .text("headphones")
    .textFieldName("description")
    .vector(queryEmbedding)
    .vectorFieldName("embedding")
    .filterExpression(Filter.tag("category", "Electronics"))
    .numResults(10)
    .build();

// Raw RediSearch filter string
HybridQuery rawFilterQuery = HybridQuery.builder()
    .text("headphones")
    .textFieldName("description")
    .vector(queryEmbedding)
    .vectorFieldName("embedding")
    .filterExpression("@category:{Electronics} @price:[100 500]")
    .numResults(10)
    .build();
----

==== Score Aliases

Name the individual scores returned by the query for downstream processing:

[source,java]
----
HybridQuery scoredQuery = HybridQuery.builder()
    .text("wireless headphones")
    .textFieldName("description")
    .vector(queryEmbedding)
    .vectorFieldName("embedding")
    .yieldTextScoreAs("text_score")
    .yieldVsimScoreAs("vector_score")
    .yieldCombinedScoreAs("combined_score")
    .numResults(10)
    .build();
----

==== Text Scorer

The default text scorer is `BM25STD`. You can change it if needed:

[source,java]
----
HybridQuery query = HybridQuery.builder()
    .text("wireless headphones")
    .textFieldName("description")
    .vector(queryEmbedding)
    .vectorFieldName("embedding")
    .textScorer("BM25STD")  // Default; also supports TFIDF, DISMAX, etc.
    .numResults(10)
    .build();
----

==== Automatic Fallback

If your Redis version does not support `FT.HYBRID`, `HybridQuery` can be converted to an `AggregateHybridQuery` automatically:

[source,java]
----
// Convert for use with Redis < 8.4
AggregateHybridQuery fallback = query.toAggregateHybridQuery();
----

The conversion maps `linearAlpha` (text weight) to `alpha` (vector weight) as `alpha = 1.0 - linearAlpha`.

=== AggregateHybridQuery (FT.AGGREGATE) — For Redis 7.4+

`AggregateHybridQuery` uses the `FT.AGGREGATE` command with a manual scoring pipeline. Use this when running Redis 7.4–8.3, or when you need explicit control over the aggregation pipeline.

==== Basic Example

[source,java]
----
import com.redis.vl.query.AggregateHybridQuery;

AggregateHybridQuery query = AggregateHybridQuery.builder()
    .text("wireless headphones")
    .textFieldName("description")
    .vector(queryEmbedding)
    .vectorFieldName("embedding")
    .alpha(0.7f)             // Vector weight (0.0-1.0, default: 0.7)
    .numResults(10)
    .returnFields(List.of("description", "category", "price"))
    .build();
----

==== Scoring Formula

[source,text]
----
hybrid_score = (1 - alpha) × BM25_score + alpha × (1 - cosine_distance)
----

Where:

* `alpha = 0.0` → Pure text search (BM25 only)
* `alpha = 0.5` → Balanced hybrid search
* `alpha = 0.7` → Default, favoring semantic similarity (recommended)
* `alpha = 1.0` → Pure vector search (semantic only)

NOTE: In `AggregateHybridQuery`, `alpha` is the **vector** weight. This is the opposite convention from `HybridQuery.linearAlpha`, which is the **text** weight.

==== Filter Expressions

[source,java]
----
AggregateHybridQuery filteredQuery = AggregateHybridQuery.builder()
    .text("headphones")
    .textFieldName("description")
    .vector(queryEmbedding)
    .vectorFieldName("embedding")
    .alpha(0.7f)
    .filterExpression(Filter.tag("category", "Electronics"))
    .numResults(10)
    .build();
----

=== Adjusting Search Behavior with Alpha

The alpha parameter controls the balance between text and vector search. Note the different conventions:

* **EntityStream / AggregateHybridQuery**: `alpha` is the **vector** weight
* **HybridQuery LINEAR mode**: `linearAlpha` is the **text** weight

**Text-Focused:**

[source,java]
----
// EntityStream: low alpha = more text weight
.hybridSearch(text, textField, vector, vectorField, 0.3f)

// HybridQuery LINEAR: high linearAlpha = more text weight
.combinationMethod(CombinationMethod.LINEAR).linearAlpha(0.7f)
----

**Balanced (50/50):**

[source,java]
----
// EntityStream
.hybridSearch(text, textField, vector, vectorField, 0.5f)

// HybridQuery LINEAR
.combinationMethod(CombinationMethod.LINEAR).linearAlpha(0.5f)
----

**Semantic-Focused (recommended):**

[source,java]
----
// EntityStream: high alpha = more vector weight
.hybridSearch(text, textField, vector, vectorField, 0.7f)

// HybridQuery LINEAR: low linearAlpha = more vector weight
.combinationMethod(CombinationMethod.LINEAR).linearAlpha(0.3f)
----

== REST API Example

Here's a REST controller implementing hybrid search:

[source,java]
----
@RestController
@RequestMapping("/api/products")
public class ProductController {

  @Autowired
  private EntityStream entityStream;

  @PostMapping("/hybrid-search")
  public List<Product> hybridSearch(
      @RequestParam String text,
      @RequestBody float[] embedding,
      @RequestParam(defaultValue = "0.7") float alpha,
      @RequestParam(required = false) String category,
      @RequestParam(defaultValue = "10") int limit
  ) {
    var stream = entityStream.of(Product.class);

    // Apply optional filters
    if (category != null) {
      stream = stream.filter(Product$.CATEGORY.eq(category));
    }

    // Execute hybrid search
    return stream
        .hybridSearch(
            text,
            Product$.DESCRIPTION,
            embedding,
            Product$.EMBEDDING,
            alpha
        )
        .limit(limit)
        .collect(Collectors.toList());
  }
}
----

== How It Works

=== Architecture

Hybrid search in Redis OM Spring uses the following architecture:

1. **Redis OM Spring API**: Provides the `hybridSearch()` fluent API via Entity Streams
2. **RedisVL Integration**: Leverages RedisVL's `HybridQuery` and `AggregateHybridQuery` implementations
3. **Redis Command Selection**:
   - **Redis 8.4+**: Uses `FT.HYBRID` with native score fusion (RRF or LINEAR)
   - **Redis 7.4+**: Uses `FT.AGGREGATE` with manual score combination pipeline
4. **Score Combination**: Merges BM25 text scores with vector similarity scores

=== Query Execution

When you call `hybridSearch()`, Redis OM Spring:

1. Stores the hybrid search parameters (deferred execution)
2. On terminal operation (e.g., `collect()`), builds a RedisVL `HybridQuery` with your parameters, combination method, and any filters/limits set on the stream
3. **Tries FT.HYBRID first** (Redis 8.4+): Executes the native hybrid command with built-in RRF or LINEAR score fusion
4. **Falls back to FT.AGGREGATE** on failure: Converts to `AggregateHybridQuery` and constructs a pipeline with text search, vector KNN search, and weighted linear score combination
5. Loads all entity fields from the results
6. Converts the results back to typed entities
7. Returns results sorted by hybrid score (highest first)

The two `hybridSearch()` overloads:

* `hybridSearch(text, textField, vector, vectorField, alpha)` — Uses LINEAR combination (backward-compatible)
* `hybridSearch(text, textField, vector, vectorField, combinationMethod, alpha)` — Choose RRF or LINEAR explicitly

=== Scoring

**HybridQuery (FT.HYBRID)** supports two combination methods:

* **RRF (Reciprocal Rank Fusion)**: Merges ranked lists without requiring score normalization. Controlled by `rrfWindow` and `rrfConstant`.
* **LINEAR**: Weighted combination where `linearAlpha` is the text weight and `(1 - linearAlpha)` is the vector weight.

**AggregateHybridQuery (FT.AGGREGATE)** uses a weighted linear formula:

[source,text]
----
hybrid_score = (1 - alpha) × BM25_score + alpha × (1 - cosine_distance)
----

Where:

* **BM25_score**: Full-text relevance score (0.0 to ~1.0)
* **cosine_distance**: Vector distance (0.0 = identical, 2.0 = opposite)
* **alpha**: Vector weight parameter (0.0 to 1.0)

Results are automatically sorted by hybrid score in descending order (highest scores first).

== Use Cases

=== E-Commerce Product Search

Search for products using both keywords and semantic similarity:

[source,java]
----
// User searches for "running shoes for marathon"
// Finds products matching:
// - Text: "marathon", "running"
// - Semantic: athletic footwear, training shoes, race day shoes

List<Product> products = entityStream.of(Product.class)
    .hybridSearch(
        "running shoes for marathon",
        Product$.DESCRIPTION,
        queryEmbedding,
        Product$.EMBEDDING,
        0.7f
    )
    .limit(20)
    .collect(Collectors.toList());
----

=== Document Search

Find relevant documents combining keyword and conceptual matching:

[source,java]
----
// Search for "contract pricing documents"
// Finds documents about:
// - Exact: contracts with "pricing" keyword
// - Semantic: agreements, terms, costs, fees

List<Document> docs = entityStream.of(Document.class)
    .filter(Document$.CATEGORY.eq("Legal"))
    .hybridSearch(
        "contract pricing documents",
        Document$.CONTENT,
        queryEmbedding,
        Document$.CONTENT_EMBEDDING,
        0.6f
    )
    .limit(10)
    .collect(Collectors.toList());
----

=== Job and Candidate Matching

Match job postings with candidate profiles:

[source,java]
----
// Find candidates for "senior software engineer Java"
// Matches both:
// - Keywords: "Java", "senior", "engineer"
// - Semantics: programming experience, backend development

List<Candidate> candidates = entityStream.of(Candidate.class)
    .filter(Candidate$.YEARS_EXPERIENCE.ge(5))
    .hybridSearch(
        "senior software engineer Java backend",
        Candidate$.RESUME_TEXT,
        jobEmbedding,
        Candidate$.SKILLS_EMBEDDING,
        0.8f  // Emphasize semantic fit
    )
    .limit(50)
    .collect(Collectors.toList());
----

=== Customer Support

Find relevant support articles:

[source,java]
----
// User asks "how to reset my password"
// Finds articles about:
// - Exact: password reset
// - Semantic: account recovery, login issues, credentials

List<Article> articles = entityStream.of(Article.class)
    .filter(Article$.STATUS.eq("published"))
    .hybridSearch(
        "how to reset my password",
        Article$.CONTENT,
        queryEmbedding,
        Article$.EMBEDDING,
        0.5f  // Balanced search
    )
    .limit(5)
    .collect(Collectors.toList());
----

== Best Practices

=== Choosing Alpha Values

**Use lower alpha (0.2-0.4) when:**

* Exact keyword matches are critical
* Users know specific terminology
* Domain has precise jargon (legal, medical)
* Query contains product codes or IDs

**Use balanced alpha (0.4-0.6) when:**

* Mix of precise and conceptual queries expected
* General-purpose search
* Users may use synonyms or variations
* Want robust performance across query types

**Use higher alpha (0.6-0.8) when:**

* Semantic meaning is more important than exact words
* Cross-language search
* Handling natural language queries
* Users describe concepts vs. using keywords

**Recommended default: 0.7** (favors semantic similarity while still considering keywords)

=== Query Vector Generation

Your query embedding should come from the same model used to generate stored embeddings:

[source,java]
----
// Example with sentence transformers
SentenceEncoder encoder = ...;
String query = "wireless headphones";
float[] queryEmbedding = encoder.encode(query);

// Use in hybrid search
List<Product> results = entityStream.of(Product.class)
    .hybridSearch(
        query,
        Product$.DESCRIPTION,
        queryEmbedding,
        Product$.EMBEDDING,
        0.7f
    )
    .collect(Collectors.toList());
----

=== Performance Optimization

**Index Configuration:**

For large datasets, use HNSW algorithm for faster vector search:

[source,java]
----
@Indexed(
    schemaFieldType = SchemaFieldType.VECTOR,
    algorithm = VectorAlgorithm.HNSW,  // Faster for large datasets
    m = 16,                             // Higher = more accurate, slower
    efConstruction = 200,               // Higher = better index quality
    dimension = 384,
    distanceMetric = DistanceMetric.COSINE
)
private byte[] embedding;
----

**Result Limiting:**

Always limit results to improve performance:

[source,java]
----
.hybridSearch(text, textField, vector, vectorField, alpha)
.limit(10)  // Limit results
----

== Demo Application

Redis OM Spring includes a complete hybrid search demo application in `demos/roms-hybrid`.

To run the demo:

[source,bash]
----
./mvnw install -Dmaven.test.skip && ./mvnw spring-boot:run -pl demos/roms-hybrid
----

The demo includes:

* Sample product data with embeddings
* REST API endpoints for hybrid search
* Examples with filters and different alpha values
* Comparison of text-only, vector-only, and hybrid search

See the link:https://github.com/redis/redis-om-spring/tree/main/demos/roms-hybrid[roms-hybrid README] for details.

== Limitations

* **Redis Version**: Minimum Redis 7.4.0+ (for `FT.AGGREGATE` with `@__score` support); Redis 8.4+ recommended for native `FT.HYBRID`
* **Projection Restrictions**: Cannot use `.map()` field projections after `.hybridSearch()` as it would switch from aggregation (FT.AGGREGATE) to search (FT.SEARCH)
* **Score Access**: The hybrid score is used for sorting but is not directly accessible on returned entities (future enhancement). Use `HybridQuery` score aliases for explicit access.
* **Runtime Parameters**: `FT.AGGREGATE` does not support HNSW runtime parameters (efRuntime, epsilon); `FT.HYBRID` does via `knnEfRuntime`

== Comparison with Standard Vector Search

[cols="1,2,2"]
|===
|Feature |Vector Search |Hybrid Search

|**Query Input**
|Vector only
|Text + Vector

|**Scoring**
|Distance/similarity only
|Combined text + vector score

|**Keyword Matching**
|No
|Yes (BM25)

|**Semantic Similarity**
|Yes
|Yes

|**Use Case**
|Pure similarity search
|General-purpose search

|**Best For**
|"Find similar items"
|"Search for items"

|**Redis Command**
|FT.SEARCH with KNN
|FT.HYBRID (8.4+) or FT.AGGREGATE (7.4+)
|===

== Related Topics

* xref:vector-search.adoc[Vector Similarity Search]
* xref:search.adoc[Redis Query Engine Integration]
* xref:entity-streams.adoc[Entity Stream Basics]
* xref:metamodel.adoc[Metamodel-Based Queries]

== Additional Resources

* link:https://redis.io/docs/interact/search-and-query/advanced-concepts/hybrid-queries/[Redis Hybrid Queries Documentation]
* link:https://redis.io/docs/interact/search-and-query/advanced-concepts/vectors/[Redis Vector Search]
* link:https://github.com/redis/redis-om-spring/tree/main/demos/roms-hybrid[Hybrid Search Demo Application]
