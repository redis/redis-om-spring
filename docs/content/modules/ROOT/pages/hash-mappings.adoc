[[hash.mappings]]
= Redis Hash Mappings with RediSearch
:page-toclevels: 3
:experimental:
:source-highlighter: highlight.js

== Introduction

Redis OM Spring fundamentally transforms how Redis Hashes work by adding RediSearch indexing capabilities on top of the standard hash storage. This is a key distinction from Spring Data Redis, which only provides basic hash operations.

=== The Core Difference

**Spring Data Redis**: Stores entities as Redis Hashes with basic secondary indexing using Redis Sets
**Redis OM Spring**: Stores entities as Redis Hashes PLUS creates RediSearch indexes for powerful querying

[source,bash]
----
# Spring Data Redis approach (basic)
HSET person:123 name "John" email "john@example.com"  # Store hash
SADD person:name:John person:123                      # Basic index

# Redis OM Spring approach (enhanced)
HSET person:123 name "John" email "john@example.com"  # Store hash (same)
FT.CREATE PersonIdx ON HASH ...                       # RediSearch index (NEW!)
----

Redis OM Spring creates full RediSearch indexes using `FT.CREATE` commands, providing:

== Key Differences from Spring Data Redis

[cols="1,2,2"]
|===
|Feature |Spring Data Redis |Redis OM Spring

|Indexing Mechanism
|Redis Sets for @Indexed fields
|RediSearch indexes via FT.CREATE

|Query Performance
|O(N) scans for complex queries
|O(log N) index-based queries

|Search Capabilities
|Basic equality checks only
|Full-text search, ranges, aggregations

|Field Types
|Simple hash fields
|TEXT, TAG, NUMERIC, GEO, VECTOR fields

|Repository Type
|CrudRepository/RedisRepository
|RedisEnhancedRepository

|Query Methods
|Limited to findBy patterns
|Complex queries, @Query, Entity Streams, SearchStream returns
|===

== Basic Usage

The examples in this page are based on a Spring Boot application with the Redis OM Spring dependency added to the POM as shown in the xref:setup.adoc[setup section].

=== Entity Definition

Redis OM Spring enables entities annotated with the `@RedisHash` annotation to be persisted as https://redis.io/docs/data-types/hashes/[Redis Hashes]:

.Sample Person Entity
====
[source,java]
----
@Data
@NoArgsConstructor(force = true)
@RequiredArgsConstructor(staticName = "of")
@AllArgsConstructor(access = AccessLevel.PROTECTED)
@RedisHash("people")
public class Person {

  @Id
  String id;
  
  @NonNull
  @Indexed
  String name;
  
  @NonNull
  @Indexed
  String email;
  
  @NonNull
  String nickname;
  
  @NonNull
  @Indexed
  Set<String> roles = new HashSet<>();
  
  @NonNull
  Set<String> favoriteFoods = new HashSet<>();
}
----
====

The key components in this entity definition are:

1. `@RedisHash("people")` - Designates this class as a Redis Hash entity with the keyspace "people"
2. `@Id` - Identifies the unique ID field (automatically generated if null)
3. `@Indexed` - Marks fields for secondary indexing to enable queries

=== Repository Definition

To take advantage of Redis OM Spring's enhanced capabilities, create a repository that extends `RedisEnhancedRepository`:

.Redis Enhanced Repository Interface
====
[source,java]
----
public interface PersonRepository extends RedisEnhancedRepository<Person, String> {
  // Custom query methods
  boolean existsByEmail(String email);
  boolean existsByNickname(String nickname);
  
  // Find by indexed fields
  Iterable<Person> findByName(String name);
  Iterable<Person> findByEmail(String email);
  
  // Find by tag field
  Iterable<Person> findByRoles(Set<String> roles);
  Iterable<Person> findByRolesContainingAll(Set<String> roles);
  
  // Custom RediSearch query
  @Query("@roles:{$roles}")
  Iterable<Person> withRoles(@Param("roles") Set<String> roles);
}
----
====

=== Enabling the Repository

Enable the repositories in your Spring Boot application:

.Application Configuration
====
[source,java]
----
@SpringBootApplication
@EnableRedisEnhancedRepositories
public class RedisOmHashesApplication {
  public static void main(String[] args) {
    SpringApplication.run(RedisOmHashesApplication.class, args);
  }
  
  @Bean
  CommandLineRunner repositoryDemo(PersonRepository repository) {
    return args -> {
      // Create and save a person
      Person person = new Person();
      person.setName("Mat Cauthon");
      person.setEmail("mat@bandoftheredhand.com");
      person.setNickname("Prince of Ravens");
      person.getRoles().add("general");
      person.getRoles().add("gambler");
      person.getFavoriteFoods().add("apple pie");
      
      // Note: Address field removed from Person model in this example
      // Focus on the roles and other simple fields
      
      repository.save(person);
      
      // Find by indexed field using Set query
      Set<String> roles = Set.of("general");
      Iterable<Person> generals = repository.findByRoles(roles);
      System.out.println("Generals: " + generals);
      
      // Note: This example uses a Company model with location field
      // List<Company> nearbyCompanies = companyRepository.findByLocationNear(
      //     new Point(15.0, 37.0), new Distance(200, Metrics.KILOMETERS));
      // System.out.println("Companies near coordinates: " + nearbyCompanies);
    };
  }
}
----
====

== Basic CRUD Operations

Once your repository is set up, you can perform standard CRUD operations:

[source,java]
----
// Create
Person newPerson = new Person();
newPerson.setName("Perrin Aybara");
newPerson.setEmail("perrin@wolfbrother.com");
repository.save(newPerson);

// Read
Optional<Person> found = repository.findById(newPerson.getId());
List<Person> allPeople = repository.findAll();

// Update
found.ifPresent(person -> {
  person.setNickname("Lord of the Two Rivers");
  repository.save(person);
});

// Delete
repository.deleteById(newPerson.getId());
----

== How Data is Stored and Indexed

Redis OM Spring stores data in standard Redis Hashes (just like Spring Data Redis) but additionally creates RediSearch indexes for querying:

=== Object-to-Hash Mapping

[cols="1,2,3"]
|===
|Java Type |Sample |Redis Hash Representation

|Simple Type (String, Number, etc.)
|`String name = "Mat";`
|`name = "Mat"`

|Enum
|`Status status = Status.ACTIVE;`
|`status = "ACTIVE"`

|Date/Time
|`LocalDate birthdate = LocalDate.of(2023, 1, 15);`
|`birthdate = "2023-01-15"`

|Complex Type
|`Address address = new Address("Tear");`
|`address.city = "Tear"`

|List/Set of Simple Type
|`List<String> nicknames = List.of("Mat", "Matrim");`
|`nicknames.[0] = "Mat"` +
`nicknames.[1] = "Matrim"`

|Map of Simple Type
|`Map<String, String> attrs = Map.of("height", "tall");`
|`attrs.[height] = "tall"`

|List of Complex Type
|`List<Address> addresses = List.of(new Address("Tear"));`
|`addresses.[0].city = "Tear"`
|===

The data is stored in a standard Redis Hash:

[source,text]
----
# Standard Redis Hash (same as Spring Data Redis)
HSET people:01HXYZ123ABC
  _class "com.example.Person"
  id "01HXYZ123ABC"
  name "Mat Cauthon"
  email "mat@bandoftheredhand.com"
  roles.[0] "general"
  roles.[1] "gambler"
  address.city "Tear"
  address.street "High Street"

# But Redis OM Spring ALSO creates a RediSearch index
FT.CREATE PersonIdx ON HASH PREFIX 1 people: SCHEMA
  name TAG SORTABLE
  email TEXT
  roles TAG SEPARATOR |
  address.city TAG
----

This dual approach means:
- Your data remains compatible with Spring Data Redis
- You get powerful search capabilities through RediSearch
- Queries use the index for performance, not scanning

== Indexing and Searching

=== How Redis OM Spring Creates Indexes

When you annotate fields with `@Indexed`, Redis OM Spring creates a RediSearch index:

[source,java]
----
@RedisHash("people")
public class Person {
  @Id
  private String id;
  
  @Indexed  // Creates a TAG field in RediSearch
  private String name;
  
  @Searchable  // Creates a TEXT field for full-text search
  private String email;
  
  @Indexed  // Creates a TAG field for set values
  private Set<String> roles;
}
----

This generates a RediSearch index creation command:

[source,text]
----
FT.CREATE PersonIdx ON HASH PREFIX 1 people: SCHEMA
  name TAG SORTABLE
  email TEXT
  roles TAG SEPARATOR |
----

NOTE: This is fundamentally different from Spring Data Redis, which would only create Redis Sets for indexed fields.

=== Advanced Field Types

Redis OM Spring supports specialized field types through RediSearch:

[source,java]
----
@RedisHash
public class Company {
  @Id
  private String id;
  
  @Indexed  // Creates a GEO field in RediSearch
  private Point location;
  
  @Searchable(sortable = true)  // Creates a TEXT field with SORTABLE
  private String name;
  
  @NumericIndexed  // Creates a NUMERIC field for range queries
  private Integer yearFounded;
  
  @TagIndexed  // Creates a TAG field for exact matches
  private Set<String> categories;
  
  @VectorIndexed(algorithm = VectorAlgorithm.HNSW)  // Vector similarity search
  private byte[] embedding;
}
----

The RediSearch index supports complex queries on these fields:

[source,text]
----
FT.CREATE CompanyIdx ON HASH PREFIX 1 Company: SCHEMA
  location GEO
  name TEXT SORTABLE
  yearFounded NUMERIC SORTABLE
  categories TAG SEPARATOR |
  embedding VECTOR HNSW 6 DIM 768 DISTANCE_METRIC COSINE
----

=== Query Methods

Define query methods in your repository interface:

[source,java]
----
public interface PersonRepository extends RedisEnhancedRepository<Person, String> {
  // Simple property query
  List<Person> findByName(String name);
  
  // Composite query (AND)
  List<Company> findByNameAndEmail(String name, String email);
  
  // Collection membership
  List<Company> findByTags(Set<String> tags);
  
  // Boolean query
  List<Company> findByPubliclyListed(boolean publiclyListed);
  
  // Geo-spatial query (using Company model with location)
  List<Company> findByLocationNear(Point point, Distance distance);
  
  // String operations
  List<Company> findByEmailStartingWith(String prefix);
  List<Company> findByEmailEndingWith(String suffix);
}
----

For detailed query capabilities, see the xref:repository-queries.adoc[Repository Query Methods] section.

== RediSearch Integration

Redis OM Spring automatically manages RediSearch indexes for your hash entities:

=== Index Creation

When your application starts, Redis OM Spring:

1. Scans for `@RedisHash` annotated classes
2. Identifies fields with indexing annotations (`@Indexed`, `@Searchable`, etc.)
3. Creates RediSearch indexes using `FT.CREATE` commands
4. Maintains index synchronization as entities are saved/deleted

=== Query Execution

Repository queries are translated to RediSearch queries:

[source,java]
----
// Repository method
List<Person> findByNameAndRolesContaining(String name, String role);

// Translates to RediSearch query
FT.SEARCH PersonIdx "@name:{John} @roles:{admin}"
----

=== Entity Streams

Redis OM Spring provides a fluent API for complex queries:

[source,java]
----
@Autowired
EntityStream entityStream;

// Complex query using Entity Streams
List<Person> admins = entityStream
  .of(Person.class)
  .filter(Person$.ROLES.contains("admin"))
  .filter(Person$.NAME.startsWith("J"))
  .sorted(Person$.EMAIL, SortOrder.ASC)
  .collect(Collectors.toList());
----

=== Entity Streams Integration with Repositories

Repositories can return `SearchStream` for fluent query operations:

[source,java]
----
import com.redis.om.spring.search.stream.SearchStream;

public interface PersonRepository extends RedisEnhancedRepository<Person, String> {
    // Return SearchStream for advanced operations
    SearchStream<Person> findByDepartment(String department);
    
    SearchStream<Person> findByAgeGreaterThan(int age);
    
    SearchStream<Person> findByActive(boolean active);
    
    // Usage example:
    // SearchStream<Person> stream = repository.findByDepartment("Engineering");
    // List<String> names = stream
    //     .filter(Person$.ACTIVE.eq(true))
    //     .map(Person$.NAME)
    //     .collect(Collectors.toList());
}
----

This allows you to combine repository query methods with the power of Entity Streams:

[source,java]
----
@Service
public class PersonService {
    @Autowired
    PersonRepository repository;
    
    public List<String> getActiveEngineerNames() {
        return repository.findByDepartment("Engineering")
            .filter(Person$.ACTIVE.eq(true))
            .map(Person$.NAME)
            .sorted()
            .collect(Collectors.toList());
    }
    
    public long countSeniorEmployees(int minAge) {
        return repository.findByAgeGreaterThan(minAge)
            .filter(Person$.DEPARTMENT.in("Engineering", "Management"))
            .count();
    }
    
    public List<Person> getTopPerformers() {
        return repository.findByActive(true)
            .filter(Person$.PERFORMANCE_SCORE.gte(90))
            .sorted(Person$.PERFORMANCE_SCORE, SortOrder.DESC)
            .limit(10)
            .collect(Collectors.toList());
    }
}
----

The `SearchStream` returned by repository methods supports all Entity Stream operations:

* **Filtering**: `filter()` with field predicates
* **Mapping**: `map()` to transform results
* **Sorting**: `sorted()` with field and order
* **Limiting**: `limit()` to restrict results
* **Aggregation**: `count()`, `findFirst()`, `anyMatch()`, `allMatch()`
* **Collection**: `collect()` to lists, sets, or custom collectors

NOTE: Fields used in SearchStream operations must be properly indexed with `@Indexed`, `@Searchable`, or other indexing annotations.

== Time To Live (TTL)

You can set expiration times for entities:

=== Class-Level TTL

[source,java]
----
@RedisHash(timeToLive = 5) // 5 seconds
public class ExpiringPerson {
  @Id
  String id;
  
  @NonNull
  String name;
}
----

=== Property-Level TTL

[source,java]
----
@RedisHash(timeToLive = 5)
public class ExpiringPerson {
  @Id
  String id;
  
  @NonNull
  String name;
  
  @NonNull
  @TimeToLive
  Long ttl; // Overrides class-level TTL
}
----

=== Default TTL (Class-Level Only)

[source,java]
----
@RedisHash(timeToLive = 5)
public class ExpiringPersonWithDefault {
  @Id
  String id;
  
  @NonNull
  String name;
  
  // Uses class-level TTL (5 seconds)
}
----

== Custom Keyspaces

You can customize the keyspace (prefix) for your entities:

=== Annotation-Based

[source,java]
----
@RedisHash("customers")
public class Person {
  // ...
}
----

=== Programmatic Configuration

[source,java]
----
@Configuration
@EnableRedisEnhancedRepositories
public class RedisConfig {
  
  @Bean
  public RedisTemplate<String, Object> redisTemplate(RedisConnectionFactory connectionFactory) {
    RedisTemplate<String, Object> template = new RedisTemplate<>();
    template.setConnectionFactory(connectionFactory);
    template.setDefaultSerializer(new GenericJackson2JsonRedisSerializer());
    return template;
  }
  
  // Custom keyspace configuration can be done through 
  // application.properties or by using different @RedisHash values
}
----

== Migration from Spring Data Redis

Migrating from Spring Data Redis to Redis OM Spring is straightforward:

1. **Change the repository interface**:
   ```java
   // Before: Spring Data Redis
   public interface PersonRepository extends CrudRepository<Person, String> { }
   
   // After: Redis OM Spring
   public interface PersonRepository extends RedisEnhancedRepository<Person, String> { }
   ```

2. **Enable enhanced repositories**:
   ```java
   // Before
   @EnableRedisRepositories
   
   // After
   @EnableRedisEnhancedRepositories
   ```

3. **Add indexing annotations** (optional but recommended):
   ```java
   @Indexed     // For exact matches
   @Searchable  // For full-text search
   @NumericIndexed  // For numeric ranges
   ```

Your existing data remains compatible, and you immediately gain access to powerful search capabilities.

== Redis Cluster Considerations

When using Redis Cluster with RediSearch indexes, use the `@IdAsHashTag` annotation to ensure proper data locality:

[source,java]
----
@RedisHash("hwht")
public class HashWithHashTagId {
  @Id
  @IdFilter(value = IdAsHashTag.class)
  private String id;
  
  @Indexed
  @NonNull
  private String name;
}
----

== Performance Considerations

* **Index-based queries**: Redis OM Spring uses RediSearch indexes, providing O(log N) query performance vs O(N) scans in Spring Data Redis
* **Storage efficiency**: Data is still stored as standard Redis Hashes, maintaining the same memory efficiency
* **Index overhead**: RediSearch indexes add some memory overhead but enable dramatic query performance improvements
* **Complex objects**: For deeply nested structures, consider xref:json_mappings.adoc[Redis JSON] documents
* **Write behavior**: Updates replace the entire hash (same as Spring Data Redis), unmapped data is lost

== Summary

Redis OM Spring enhances Redis Hash entities with RediSearch indexing, providing:

* **Full compatibility** with Spring Data Redis hash storage
* **Powerful search capabilities** through RediSearch indexes
* **O(log N) query performance** instead of O(N) scans
* **Rich query methods** including full-text search, ranges, and aggregations
* **Advanced field types** like vectors, geo-spatial, and more

The key takeaway: Redis OM Spring doesn't change how hashes are stored, it adds a powerful search layer on top.

== Next Steps

* xref:json_mappings.adoc[Redis JSON Mappings] - Compare with JSON document mapping
* xref:repository-queries.adoc[Repository Query Methods] - Learn about query capabilities
* xref:entity-streams.adoc[Entity Streams] - Explore fluent query API
* xref:search.adoc[Redis Query Engine Integration] - Understand the search capabilities
* xref:index-annotations.adoc[Index Annotations] - Deep dive into indexing options